package main

import (
	"context"
	"net/http"
	"time"

	"github.com/gocql/gocql"
	maps "github.com/gronka/google-maps-services-go"
	"github.com/julienschmidt/httprouter"
	log "github.com/sirupsen/logrus"
	//"googlemaps.github.io/maps"
)

// TODO: ensure groups can also create/select tacs
type UserHasTacsModel struct {
	UserUuid gocql.UUID `json:"userUuid,omitempty"`
	LastUsed int64      `json:"last_used,omitempty"`
	TacUuid  gocql.UUID `json:"tacUuid,omitempty"`
	Name     string     `json:"name,omitempty"`
	Address  string     `json:"address,omitempty"`
	Lat      float64    `json:"lat,omitempty"`
	Lng      float64    `json:"lng,omitempty"`
	TzOffset int        `json:"tzOffset,omitempty"`
	TzId     string     `json:"tzId,omitempty"`
}

type TacPayload struct {
	RequesteeUuid gocql.UUID `json:"requesteeUuid,omitempty"`

	// programmatic fields
	Status string `json:"status,omitempty"`

	// generated by client
	latLngString string `json:"latLngString,omitempty"`

	// user created fields
	Name    string  `json:"name,omitempty"`
	Address string  `json:"address,omitempty"`
	Lat     float64 `json:"lat,omitempty"`
	Lng     float64 `json:"lng,omitempty"`

	// fields from google
	TzOffset           int     `json:"tzOffset,omitempty"`
	GgPlaceId          string  `json:"ggPlaceId,omitempty"`
	GgName             string  `json:"ggName,omitempty"`
	GgFormattedAddress string  `json:"ggFormattedAddress,omitempty"`
	GgLat              float64 `json:"ggLat,omitempty"`
	GgLng              float64 `json:"ggLng,omitempty"`
	MapsUrl            string  `json:"mapsUrl,omitempty"`
	// this field is only set on manual lookup
	TzId string `json:"tzId,omitempty"`
}

func (tac *UserHasTacsModel) load() {
	query := `SELECT * FROM user_has_tacs WHERE user_uuid=? AND tac_uuid=?`
	iter := s.Query(query, tac.UserUuid, tac.TacUuid).Iter()

	row := map[string]interface{}{
		"user_uuid": &tac.UserUuid,
		"tac_uuid":  &tac.TacUuid,
		"last_used": &tac.LastUsed,
		"name":      &tac.Name,
		"address":   &tac.Address,
		"lat":       &tac.Lat,
		"lng":       &tac.Lng,
		"tz_offset": &tac.TzOffset,
		"tz_id":     &tac.TzId,
	}
	iter.MapScan(row)

	err := iter.Close()
	check(err, "failed to close iter")
}

func (pl *TacPayload) save(userUuid gocql.UUID) {
	// TODO (high): if tzOffset isn't defined by google, then it should come from a lookup on lat/lng
	lastUsed := timeNowMilli()
	tacUuid, _ := gocql.RandomUUID()
	stmt := `INSERT INTO user_has_tacs (user_uuid, last_used, tac_uuid, name, address, lat, lng, tz_offset, tz_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
	err := s.Query(stmt, userUuid, lastUsed, tacUuid, pl.Name, pl.Address, pl.Lat, pl.Lng, pl.TzOffset, pl.TzId).Exec()
	check(err, "Failed to insert user_has_tacs")

	stmt = `INSERT INTO tac_has_gg_place (tac_uuid, gg_place_id, gg_name, gg_formatted_address, gg_lat, gg_lng, maps_url, tz_offset, tz_id) VALUES (?, ?, ?, ?, ?, ?, ?, ?, ?)`
	err = s.Query(stmt, tacUuid, pl.GgPlaceId, pl.GgName, pl.GgFormattedAddress, pl.GgLat, pl.GgLng, pl.MapsUrl, pl.TzOffset, pl.TzId).Exec()
	check(err, "Failed to insert tac_has_gg_place")
}

func hAddTac(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	gibs := unpackReqIntoGibs(w, r, P_PUBLIC)
	var pl TacPayload
	decodeJson(r, &pl)
	log.Info(pl)

	if pl.GgPlaceId == "" {
		client, err := maps.NewClient(maps.WithAPIKey(Conf.mapsac))
		check(err, "failed to create mapsac client")

		time := time.Time{}
		// Use timestamp 0 (jan 1) to avoid daylights saving confusion
		mapsacReq := &maps.TimezoneRequest{
			Language:  "en",
			Timestamp: time,
		}
		mapsacParseLocation(pl.latLngString, mapsacReq)

		mapsacRes, err := client.Timezone(context.Background(), mapsacReq)
		check(err, "error on timezone lookup")

		pl.TzOffset = mapsacRes.DstOffset
		pl.TzId = mapsacRes.TimeZoneID
	}

	pl.save(gibs.UserUuid)

	gibs.ares.Info = ACCEPTED
	gibs.encodeResponse(w)
}

func hGetTacsByUserUuid(w http.ResponseWriter, r *http.Request, ps httprouter.Params) {
	gibs := unpackReqIntoGibs(w, r, P_PUBLIC)
	var pl TacPayload
	decodeJson(r, &pl)
	log.Info(pl)
	ok := gibs.TacRequesteeCanViewTacs(pl.RequesteeUuid)
	if !ok {
		panic("AUTHERROR: requestee not allowed to view tacs")
	}

	query := `SELECT * FROM user_has_tacs WHERE user_uuid=?`
	iter := s.Query(query, gibs.UserUuid).Iter()

	var tacs []UserHasTacsModel
	var buf UserHasTacsModel
	for {
		row := map[string]interface{}{
			"user_uuid": &buf.UserUuid,
			"last_used": &buf.LastUsed,
			"tac_uuid":  &buf.TacUuid,
			"name":      &buf.Name,
			"address":   &buf.Address,
			"lat":       &buf.Lat,
			"lng":       &buf.Lng,
			"tz_offset": &buf.TzOffset,
		}
		if !iter.MapScan(row) {
			break
		}
		tacs = append(tacs, buf)
	}
	err := iter.Close()
	check(err, "failed to close iter")

	gibs.ares.Info = ACCEPTED
	gibs.ares.Body["results"] = tacs
	gibs.encodeResponse(w)
}
